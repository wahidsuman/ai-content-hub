export function isESMImportedImage(src) {
    return typeof src === 'object';
}
export function isRemotePath(src) {
    return /^(http|ftp|https|ws):?\/\//.test(src) || src.startsWith('data:');
}
export function matchHostname(url, hostname, allowWildcard) {
    if (!hostname) {
        return true;
    }
    if (!allowWildcard || !hostname.startsWith('*')) {
        return hostname === url.hostname;
    }
    if (hostname.startsWith('**.')) {
        const slicedHostname = hostname.slice(2); // ** length
        return slicedHostname !== url.hostname && url.hostname.endsWith(slicedHostname);
    }
    if (hostname.startsWith('*.')) {
        const slicedHostname = hostname.slice(1); // * length
        const additionalSubdomains = url.hostname
            .replace(slicedHostname, '')
            .split('.')
            .filter(Boolean);
        return additionalSubdomains.length === 1;
    }
    return false;
}
export function matchPort(url, port) {
    return !port || port === url.port;
}
export function matchProtocol(url, protocol) {
    return !protocol || protocol === url.protocol.slice(0, -1);
}
export function matchPathname(url, pathname, allowWildcard) {
    if (!pathname) {
        return true;
    }
    if (!allowWildcard || !pathname.endsWith('*')) {
        return pathname === url.pathname;
    }
    if (pathname.endsWith('/**')) {
        const slicedPathname = pathname.slice(0, -2); // ** length
        return slicedPathname !== url.pathname && url.pathname.startsWith(slicedPathname);
    }
    if (pathname.endsWith('/*')) {
        const slicedPathname = pathname.slice(0, -1); // * length
        const additionalPathChunks = url.pathname
            .replace(slicedPathname, '')
            .split('/')
            .filter(Boolean);
        return additionalPathChunks.length === 1;
    }
    return false;
}
export function matchPattern(url, remotePattern) {
    return (matchProtocol(url, remotePattern.protocol) &&
        matchHostname(url, remotePattern.hostname, true) &&
        matchPort(url, remotePattern.port) &&
        matchPathname(url, remotePattern.pathname, true));
}
export function isRemoteAllowed(src, { domains = [], remotePatterns = [], }) {
    if (!isRemotePath(src))
        return false;
    const url = new URL(src);
    return (domains.some((domain) => matchHostname(url, domain)) ||
        remotePatterns.some((remotePattern) => matchPattern(url, remotePattern)));
}
export function isString(path) {
    return typeof path === 'string' || path instanceof String;
}
export function removeTrailingForwardSlash(path) {
    return path.endsWith('/') ? path.slice(0, path.length - 1) : path;
}
export function removeLeadingForwardSlash(path) {
    return path.startsWith('/') ? path.substring(1) : path;
}
export function trimSlashes(path) {
    return path.replace(/^\/|\/$/g, '');
}
export function joinPaths(...paths) {
    return paths
        .filter(isString)
        .map((path, i) => {
        if (i === 0) {
            return removeTrailingForwardSlash(path);
        }
        if (i === paths.length - 1) {
            return removeLeadingForwardSlash(path);
        }
        return trimSlashes(path);
    })
        .join('/');
}
